
一.构造正则表达式有两种方法：
1.使用一个正则表达式字面量：/pattren/flags
const  regex=/[bc]at/i;
2.调用RegExp对象的构造函数：new RegExp(pattern [, flags])
let regex = new RegExp("[bc]at","i");
  注：pattern
      正则表达式的文本。
      flags
      如果指定，标志可以具有以下值的任意组合：
      g
      全局匹配;找到所有匹配，而不是在第一个匹配后停止
      i
      忽略大小写
      m
      多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。
      u
      Unicode; 将模式视为Unicode序列点的序列
      y
      粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。
二.正则表达式的方法
exec	一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。
例子：var myRe = /d(b+)d/g;
     var myArray = myRe.exec("cdbbdbsbz");
test	一个在字符串中测试是否匹配的RegExp方法，它返回true或false。

match	一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。
search	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
replace	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
split	一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。
注：1.当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；
    想得到更多的信息（但是比较慢）则可以使用exec或match方法。
    如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象。
    如果匹配失败，那么exec方法返回null（也就是false）。
    2./a(b)c /可以匹配字符串“abc”，并且记得“b”;
      模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\*/ 将 '*' 的特殊性移除，从而可以匹配像 "a*" 这样的字符串。
 三.特殊字符串
    ^：匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。
       例如，/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。
       ^[0~9] 以数字开头
       [^0~9] 取反，非数字
    $	
      匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。
      例如，/t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。
    *	
      匹配前一个表达式0次或多次。等价于 {0,}。
      例如，/bo*/会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中将不会匹配任何东西。
    +	
      匹配前面一个表达式1次或者多次。等价于 {1,}。
      例如，/a+/匹配了在 "candy" 中的 'a'，和在 "caaaaaaandy" 中所有的 'a'。
    ?	
      匹配前面一个表达式0次或者1次。等价于 {0,1}。
      例如，/e?le?/ 匹配 "angel" 中的 'el'，和 "angle" 中的 'le' 以及"oslo' 中的'l'。
      如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。
      例如，对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。
    .	
      （小数点）匹配除换行符之外的任何单个字符。
       例如，/.n/将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。
    []
      [0~9]表示0到9之间任意的数字。
      [1][0~9][0~9]表示100到199的数字。
      [a-zA-z]表示所有字母中的任意一个。
      [.]把元字符中的.的意义干掉
    （） 
        提升优先级  分组
     {}
       {5,10}前面的表达式出现5次到10次
    (x)	
      匹配 'x' 并且记住匹配项。括号被称为 捕获括号。
      模式/(foo) (bar) \1 \2/中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。
      注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。

    (?:x)	
      匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。
      来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。
   
   x(?=y)	
      匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。
      例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。

    x(?!y)	
    匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。
    例如，/\d+(?!\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’但是不是‘3.141’

    x|y	
    匹配‘x’或者‘y’。
    例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’

    {n}	
    n是一个正整数，匹配了前面一个字符刚好发生了n次。
    比如，/a{2}/不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'。

    {n,m}	
    n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。
    例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。
    注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。

    [xyz]	
    一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。
    例如，[abcd] 和[a-d]是一样的。他们都匹配"brisket"中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/都匹配“test.i.ng”中的所有字符。

    [^xyz]	
    一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。
    例如，[^abc] 和 [^a-c] 是一样的。他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。

    [\b]	
    匹配一个退格(U+0008)。（不要和\b混淆了。）

    \b	
    匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。
    注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）
    例子：

    /\bm/匹配“moon”中得‘m’；

    /oo\b/并不匹配"moon"中得'oo'，因为'oo'被一个“字”字符'n'紧跟着。

    /oon\b/匹配"moon"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。

    /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。
    
    \B	
    匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是“字”字符或者都不是“字”字符。一个字符串的开始和结尾都被认为不是“字”字符，或者空字符串。
    例如，/\B../匹配"noonday"中的'oo', 而/y\B../匹配"possibly yesterday"中的’yes‘

    \cX	
    当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。
    例如，/\cM/ 匹配字符串中的 control-M (U+000D)。

    \d	
    匹配一个数字。
    等价于[0-9]。
    例如， /\d/ 或者 /[0-9]/ 匹配"B2 is the suite number."中的'2'。

    \D	
    匹配一个非数字字符。
    等价于[^0-9]。
    例如， /\D/ 或者 /[^0-9]/ 匹配"B2 is the suite number."中的'B' 。

    \f	匹配一个换页符 (U+000C)。
    \n	匹配一个换行符 (U+000A)。
    \r	匹配一个回车符 (U+000D)。
   
   \s	
    匹配一个空白字符，包括空格、制表符、换页符和换行符。
    等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。
    例如, /\s\w*/ 匹配"foo bar."中的' bar'。
    \S	
    匹配一个非空白字符。
    等价于[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。
    例如， /\S\w*/ 匹配"foo bar."中的'foo'。

    \t	匹配一个水平制表符 (U+0009)。
    \v	匹配一个垂直制表符 (U+000B)。
    \w	
    匹配一个单字字符（字母、数字或者下划线）（非特殊符号）
    等价于[A-Za-z0-9_]。
    例如, /\w/ 匹配 "apple," 中的 'a'，"$5.28,"中的 '5' 和 "3D." 中的 '3'。

    \W	
    匹配一个非单字字符。（特殊符号）
    等价于[^A-Za-z0-9_]。
    例如, /\W/ 或者 /[^A-Za-z0-9_]/ 匹配 "50%." 中的 '%'。

    \n	
    在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。

    比如 /apple(,)\sorange\1/ 匹配"apple, orange, cherry, peach."中的'apple, orange,' 。

    \0	匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \0<digits> 是一个八进制转义序列。
    \xhh	与代码 hh 匹配字符（两个十六进制数字）
    \uhhhh	与代码 hhhh 匹配字符（四个十六进制数字）。
    \u{hhhh}	(仅当设置了u标志时) 使用Unicode值hhhh匹配字符 (十六进制数字).
    
 (\-|\+?) 匹配±号
(\-?) 匹配-号或没有负号（正数）
\d+匹配至少1个数字

参考：百度 正则表达式
      MDN 正则表达式
